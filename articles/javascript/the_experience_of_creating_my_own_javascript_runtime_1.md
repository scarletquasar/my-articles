# The experience of creating my own JavaScript runtime - #1

Hello everyone, for a while (a few months) I came up with the idea of developing my own JavaScript runtime, written in C# using Jint. At first it seemed unfeasible, or at least difficult enough, but I had already tried to assemble a project (for a hobby, like this one) using its own JavaScript engine, [HTAPPS](https://github.com/EternalQuasar0206/Htapps.NET), whose focus was to do the same thing as Electron, however, in a lightweight way (and only for windows, as it used the standard IE frame to execute).

The current development repository can be [accessed](https://github.com/MelonRuntime/MelonRuntime) here.

**But why?** I decided to start this project as a pure hobby, and among the main reasons why I started the project are:

- I thought about how Node.js was created in its beginnings, it was the opportunity to build something similar in CSharp, my specialty
- I needed my own automation tool, I'm not very into Python but TypeScript/JavaScript would be a perfect thing to do it. Node can handle it, but there are some "raw" things that make me very uncomfortable
- I need something to present as my college graduation project (yes)

## First steps

[MelonRuntime](https://github.com/MelonRuntime/MelonRuntime) is based on [Jint](https://github.com/sebastienros/jint), a JavaScript interpreter created by SÃ©bastien Ros, software developer in the ASP.NET team at Microsoft. Melon works from bindings and functionalities injected into this interpreter together with external typing (provided by another package that comes with the default project generated by the command `npx melon new`) and built-in tools. 

The first days were very fun, I had to learn how to inject functionality into the engine (binding what is C# and what is JavaScript) and being able to call them from within the code. For that I had (and still have the help) of a library that I created myself, called [CLI.NET](https://github.com/EternalQuasar0206/Cli.NET), to create command interfaces quickly.

- **Tip**: I do not recommend using CLI.NET for production, there is no Nuget package and I had to perform some optimizations, the original repository needs attention

The first binding was to implement a basic `console` tool, and the first function was obviously `log`:

![First console.log example](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/eh62baccpp83aztiwjlx.png)

The implementation was a mess (I think it still), but I like it, and I have to improve it more and more. Currently, there is the implementation:

```cs
public static void Write(object obj, int color)
{
    CLNConsole.Write("< ", ConsoleColor.Red);

    try
    {
        JsonSerializerOptions options = new()
        {
            ReferenceHandler = ReferenceHandler.IgnoreCycles,
            WriteIndented = true
        };

        var serialized = JsonSerializer.Serialize(obj, options);
        CLNConsole.Write(serialized, color);
    }
    catch
    {
        CLNConsole.Write(obj.ToString() ?? "null", color);
    }

    Console.WriteLine();
}
```

After that, I was focused in turning the errors more readable, like that:

![First exception message implementation](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lz8ycewe0ydawlr2db6i.png)

There is still a long way to go.
